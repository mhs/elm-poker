-- Do not manually edit this file, it was auto-generated by Graphqelm
-- https://github.com/dillonkearns/graphqelm


module PokerApi.Mutation exposing (..)

import Graphqelm.Field as Field exposing (Field)
import Graphqelm.Internal.Builder.Argument as Argument exposing (Argument)
import Graphqelm.Internal.Builder.Object as Object
import Graphqelm.Internal.Encode as Encode exposing (Value)
import Graphqelm.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphqelm.OptionalArgument exposing (OptionalArgument(Absent))
import Graphqelm.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import PokerApi.InputObject
import PokerApi.Interface
import PokerApi.Object
import PokerApi.Scalar
import PokerApi.Union


{-| Select fields to build up a top-level mutation. The request can be sent with
functions from `Graphqelm.Http`.
-}
selection : (a -> constructor) -> SelectionSet (a -> constructor) RootMutation
selection constructor =
    Object.selection constructor


type alias CloseRoundRequiredArguments =
    { id : PokerApi.Scalar.Id }


{-| Closes the current round without opening a new one
-}
closeRound : CloseRoundRequiredArguments -> SelectionSet decodesTo PokerApi.Object.Round -> Field (Maybe decodesTo) RootMutation
closeRound requiredArgs object =
    Object.selectionField "closeRound" [ Argument.required "id" requiredArgs.id (\(PokerApi.Scalar.Id raw) -> Encode.string raw) ] object (identity >> Decode.nullable)


type alias CreateGameRequiredArguments =
    { name : String }


{-| Create a game
-}
createGame : CreateGameRequiredArguments -> SelectionSet decodesTo PokerApi.Object.Game -> Field (Maybe decodesTo) RootMutation
createGame requiredArgs object =
    Object.selectionField "createGame" [ Argument.required "name" requiredArgs.name Encode.string ] object (identity >> Decode.nullable)


type alias DeleteGameRequiredArguments =
    { id : PokerApi.Scalar.Id }


{-| Delete a game
-}
deleteGame : DeleteGameRequiredArguments -> SelectionSet decodesTo PokerApi.Object.Game -> Field (Maybe decodesTo) RootMutation
deleteGame requiredArgs object =
    Object.selectionField "deleteGame" [ Argument.required "id" requiredArgs.id (\(PokerApi.Scalar.Id raw) -> Encode.string raw) ] object (identity >> Decode.nullable)


type alias JoinGameRequiredArguments =
    { id : PokerApi.Scalar.Id }


{-| Join a game with the current user
-}
joinGame : JoinGameRequiredArguments -> SelectionSet decodesTo PokerApi.Object.Game -> Field (Maybe decodesTo) RootMutation
joinGame requiredArgs object =
    Object.selectionField "joinGame" [ Argument.required "id" requiredArgs.id (\(PokerApi.Scalar.Id raw) -> Encode.string raw) ] object (identity >> Decode.nullable)


type alias LeaveGameRequiredArguments =
    { id : PokerApi.Scalar.Id }


{-| Leave a game with the current user
-}
leaveGame : LeaveGameRequiredArguments -> SelectionSet decodesTo PokerApi.Object.Game -> Field (Maybe decodesTo) RootMutation
leaveGame requiredArgs object =
    Object.selectionField "leaveGame" [ Argument.required "id" requiredArgs.id (\(PokerApi.Scalar.Id raw) -> Encode.string raw) ] object (identity >> Decode.nullable)


type alias LoginRequiredArguments =
    { email : String }


{-| Logs in a user by email
-}
login : LoginRequiredArguments -> SelectionSet decodesTo PokerApi.Object.Session -> Field (Maybe decodesTo) RootMutation
login requiredArgs object =
    Object.selectionField "login" [ Argument.required "email" requiredArgs.email Encode.string ] object (identity >> Decode.nullable)


type alias NextRoundRequiredArguments =
    { gameId : PokerApi.Scalar.Id }


{-| Creates a new round for the given game, also creates new estimates for all players
-}
nextRound : NextRoundRequiredArguments -> SelectionSet decodesTo PokerApi.Object.Round -> Field (Maybe decodesTo) RootMutation
nextRound requiredArgs object =
    Object.selectionField "nextRound" [ Argument.required "gameId" requiredArgs.gameId (\(PokerApi.Scalar.Id raw) -> Encode.string raw) ] object (identity >> Decode.nullable)


type alias UpdateEstimateOptionalArguments =
    { amount : OptionalArgument String }


type alias UpdateEstimateRequiredArguments =
    { id : PokerApi.Scalar.Id }


{-| Changes the amount on an arbitrary estimate
-}
updateEstimate : (UpdateEstimateOptionalArguments -> UpdateEstimateOptionalArguments) -> UpdateEstimateRequiredArguments -> SelectionSet decodesTo PokerApi.Object.Estimate -> Field (Maybe decodesTo) RootMutation
updateEstimate fillInOptionals requiredArgs object =
    let
        filledInOptionals =
            fillInOptionals { amount = Absent }

        optionalArgs =
            [ Argument.optional "amount" filledInOptionals.amount Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionField "updateEstimate" (optionalArgs ++ [ Argument.required "id" requiredArgs.id (\(PokerApi.Scalar.Id raw) -> Encode.string raw) ]) object (identity >> Decode.nullable)
